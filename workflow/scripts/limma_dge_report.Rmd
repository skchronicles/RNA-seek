---
title: "Limma Report"
subtitle: "Differential Gene Expression Analysis"
author: "[OpenOmics/RNA-seek](https://github.com/OpenOmics/RNA-seek)"
date: "`r Sys.Date()`"
params:
    raw: "DEG_ALL/RSEM_genes_expected_counts.tsv"
    group: "groups.tsv"
    contrasts: "contrasts.tsv"
    # Covariates example: "Batch,Sex,Site" or "Batch"
    covariates: NULL
    prefix: "comparison_prefix"
    wdir: "results"
output: 
    html_document:
        self_contained: true
        code_download: true
        code_folding: hide
        toc: true
        toc_depth: 4
        toc_float: true
        number_sections: true
---

```{r setup, include=FALSE}

# Set the working directory
wd <- params$wdir
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = wd)
knitr::opts_chunk$set(warning = FALSE, message = FALSE)

# Misc helper functions
err <- function(...){cat(sprintf(...), sep='\n', file=stderr())}
fatal <- function(...) {err(...); quit(status = 1)}
timestamp <- function(..., sep = " ") {
  ts <- format(Sys.time(), "%Y-%m-%d %H:%M:%S")
  args <- list(...)
  # convert each argument to a printable string
  txt <- vapply(args, function(x) {
    if (is.data.frame(x) || is.matrix(x) || is.list(x)) {
      paste(capture.output(print(x)), collapse = "\n")
    } else {
      paste(as.character(x), collapse = sep)
    }
  }, character(1))
  cat(sprintf("\n[%s] %s\n", ts, paste(txt, collapse = sep)), sep = "", file = stderr())
}
```

## About

This report contains the results of differential gene expression (DGE) analysis using the [R package limma](https://bioconductor.org/packages/release/bioc/html/limma.html).

This report includes data pre-processing steps to filter out lowly expressed genes, estimate scaling factors for normalization, and transform the raw counts into log2 counts per million (log2CPM) values using the `voom` method to account for mean-variance relationship in RNA-seq data. After data normalization, exploratory principal component analysis (PCA) was performed to examine inter-sample clustering and detect potential outliers.

Differential gene expression analysis was performed using the limma functions `lmFit`, `contrasts.fit`, and `eBayes`. The differential expression results are presented in interactive tables and volcano plots for each comparison of interest.

## Sample Sheet  

```{r init-global, results='asis'}
# Bioconductor package imports
# Install via:
#   BiocManager::install('packageName'))
suppressMessages(library("limma"))
suppressMessages(library("edgeR"))
suppressMessages(library("Glimma"))
suppressMessages(library("EnhancedVolcano"))


# CRAN package imports
# Install via:
#   install.packages('packageName')
suppressMessages(library("plotly"))
suppressMessages(library("ggplot2"))
suppressMessages(library("DT"))
suppressMessages(library("knitr"))
suppressMessages(library("RColorBrewer"))
suppressMessages(library("tidyverse"))
suppressMessages(library("dplyr"))
suppressMessages(library("stringr"))
suppressMessages(library("corrplot"))
suppressMessages(library("htmlwidgets"))

# Get prefix for output files
prefix <- params$prefix

# Reading in raw counts matrix
raw <- read.table(
    file = params$raw,
    sep = "\t",
    header = TRUE,
    row.names = 1,
    quote = ""
)

# Reading in sample sheet,
# contains sample to group
# information
groupinfo <- read.table(
    file = params$group,
    sep = "\t",
    header = TRUE,
    stringsAsFactors = TRUE
)
rownames(groupinfo) = make.names(groupinfo$Sample)

# Reading in contrasts file,
# contains comparisons of interest
contrastinfo <- read.table(
    file = params$contrasts,
    sep = "\t",
    header = FALSE,
    stringsAsFactors = TRUE
)

# Reorder the columns of the counts
# matrix to match the order of the
# Sample column of groupinfo TSV,
# Samples with names that do not
# match are dropped
grp_idx <- match(make.names(colnames(raw)), row.names(groupinfo), nomatch = 0)
groupinfo <- groupinfo[grp_idx,]

# Check for other NULL-like data
# types for covariates, like an
# empty string or NA, and set it
# to NULL for consistency
if (!is.null(params$covariates)) {
  if (params$covariates == "" || is.na(params$covariates)) {
    params$covariates <- NULL
  }
}

# Check if covariates are in
# sample sheet, if provided
run_corrected_pca <- FALSE
if (!is.null(params$covariates)) {
  # Dynamically creates a tab
  # with normalized, covariate
  # corrected counts
  run_corrected_pca <- TRUE
  user_covars <- unlist(strsplit(params$covariates, split = ","))
  missing_covars <- setdiff(user_covars, colnames(groupinfo))
  if (length(missing_covars) > 0) {
    # Some covariates are missing,
    # did not pass sanity check
    stop(paste("Fatal error: The following covariates are missing from the sample sheet:", paste(missing_covars, collapse = ", ")))
  }
}

# Set working/output directory
# after reading in input files,
# ensure relative paths are read
# in correctly before changing
# the working directory. If the
# working/output directory does
# not exist, it will be created
if (!dir.exists(wd) ) {
  dir.create(wd, recursive = TRUE)
  set.wd(wd)
}

# Note the use of the results='asis' chunk
# option above. This is required to ensure 
# that the raw table output isn’t processed
# further by knitr.
# Create interactive datatable with metadata
DT::datatable(
    groupinfo,
    extensions = c(
      "Buttons",       # add download buttons
      "Scroller",      # for scrolling instead of pagination
      "FixedColumns",  # freeze columns in datatable
      "SearchBuilder"  # create complex search queries
    ),
    rownames = FALSE,  # keep rownames
    style = "auto",
    width = "100%",
    options = list(
      dom = "QBflrtip", # specify content (search box, etc)
      deferRender = TRUE,
      scrollX = TRUE,
      scrollY = min(400, 40 * nrow(groupinfo)), # max height 400px
      scroller = TRUE,
      fixedColumns = list(leftColumns = 1), # freeze left columns
      buttons = list(
        list(
            extend = "csv",             # download as .csv
            filename = "groups_file"    # output file
        ),
        list(
            extend = "excel",           # download as .xlsx
            filename = "groups_file"    # output file
        )
      )
    ),
)
```

The sample sheet above links each sample to its associated metadata. It includes a **Group** column representing the experimental groups of interest— such as time points, treatments, conditions, genotypes status, or disease states. The **Group** information is used to construct the design matrix for linear modeling in limma, enabling comparisons between groups to identify differentially expressed genes.

## Pre-processing

### Filtering

Before identifying differentially expressed genes, it is important to remove lowly expressed genes. 

As the author of limma notes:

> Genes not expressed at biologically meaningful levels in any condition are uninformative and should be excluded. Statistically, filtering out low-count genes improves estimation of the mean–variance relationship and reduces the number of tests performed during differential expression analysis.

### Normalization

Differential expression analysis **should not** be performed on raw counts. Raw counts are biased by library size (i.e sequencing depth): samples with greater sequencing depth yield higher counts. To correct for this, counts are normalized to account for sequencing depth and transformed to `log2(CPM + pseudocount)` using `limma::voom()`. The `voom()` function adds a small pseudocount (0.5) to avoid taking the log of zero.

Normalization also ensures comparable expression distributions across samples. The trimmed mean of M-values (TMM) method, implemented in `edgeR::calcNormFactors()`, calculates scaling factors applied to library sizes. This step is essential to remove systematic biases that can arise from differences in sequencing depth or RNA composition between samples. Without proper normalization, any observed differences in expression may reflect technical artifacts rather than true biological variation.

RNA-sequencing counts exhibit a mean–variance relationship: variance increases with mean count. Modeling this heteroscedasticity is essential. While methods using the Negative Binomial distribution assume a quadratic mean–variance relationship, limma models log2CPM values as approximately normally distributed. `limma::voom()` estimates the mean–variance trend in log-counts, assigns precision weights based on predicted variance, and incorporates these weights in linear modeling to adjust for heteroscedasticity. Accurately modeling this relationship increases statistical power and reduces false discoveries, ensuring that identified differentially expressed genes reflect true biological differences rather than variation caused by count magnitude or technical noise.

<details>
  <summary>*View Mean–Variance Plot*</summary>
```{r pre-processing, out.width="100%"}
# Create DGEList object with edgeR
group <- as.factor(groupinfo$Group)
deg <- edgeR::DGEList(counts = raw, group = group)

# Calculate log2CPM for exploratory plots,
# when is set to TRUE, the cpm() function
# adds an offset to the CPM values before
# converting to the log2-scale.
raw.cpm <- edgeR::cpm(raw, log = TRUE)

# Filter lowly expressed genes
# Gene must have 10 reads in >= 70% samples.
# The actual filtering uses CPM values rather
# than counts in order to avoid biases to
# samples with large library sizes.
keep_genes <- edgeR::filterByExpr(deg, group = group)
# Recaluate new lib.sizes after filtering
deg <- deg[keep_genes, , keep.lib.sizes = FALSE]

# Used to create plots before/after
# filtering for lowly expressed genes
filtered.cpm <- edgeR::cpm(deg, log = TRUE)

# edgeR TMM normalization, just calculates
# norm scaling factors for use downstream.
# These factors are automatically stored in
# the resulting DEGList object.
deg <- edgeR::calcNormFactors(deg, method = "TMM")

# Creating using Group information,
# Adding `0+` will create a model
# without an intercept term, for
# groups that are factors this is 
# the recommended method as interpreting
# which group become the intercept can
# confusing (especially in more complex
# designs). When `0+` is not provided
# the first group becomes the intercept,
# as called a mean-reference model.
# Again when working with groups that
# are factors (categorical), it does
# not matter; however, for continuous
# group variables, it does matter.
if (is.null(params$covariates)) {
  # No covariates were provided, only
  # use Group information
  timestamp("No covariates were provided.")
  formula <- as.formula("~0 + Group")
  timestamp("Using design formula:\n", deparse(formula))
  # Create design matrix and remove
  # "Group" prefix from column names
  design <- model.matrix(formula, data = groupinfo)
  colnames(design) <- gsub("Group", "", colnames(design))
  timestamp("Using design matrix:\n", as.data.frame(design))
} else {
  # Covariates were provided, add them
  # to design formula, Group should be
  # the first term in the formula
  timestamp("Covariates were provided.")
  # Building formula, i.e.
  # ~0 + Group + Cov1 + Cov2 + CovN
  covariate_terms <- gsub(",", " + ", params$covariates)
  formula <- paste("~0 + Group + ", covariate_terms)
  formula <- as.formula(formula)
  timestamp("Using design formula:\n", deparse(formula))
  # Create design matrix and remove
  # "Group" and the covariate term
  # prefixes from the column names
  design <- model.matrix(formula, data = groupinfo)
  colnames(design) <- gsub("Group", "", colnames(design))
  for (cov in unlist(strsplit(params$covariates, split = ","))) {
    colnames(design) <- gsub(cov, "", colnames(design))
  }
  timestamp("Using design matrix:\n", as.data.frame(design))
}

# limma voom() transforms the counts
# into log2CPM, where “per million reads”
# is defined based on the normalization
# factors we calculated earlier with edgeR.
# A linear model is fitted to the log2CPM
# for each gene, and the residuals are
# calculated. A smoothed curve is fitted
# to the sqrt(residual standard deviation)
# by average expression, seen red line in
# voomplot. The smoothed curve is used to
# obtain weights for each gene and sample
# that are passed into limma along with
# the log2CPMs.
voom_object <- limma::voom(deg, design, plot = TRUE)

# lmFit fits a linear model using weighted
# least squares for each gene, and now
# comparisons between groups (log2FC) can
# be obtained as contrasts of these fitted
# linear models.
fit <- limma::lmFit(voom_object, design)

# Write the voom object, normalized
# counts to an output file for any
# later data visualization requests
write.table(
  data.frame("ensid_gene" = rownames(voom_object$E), voom_object$E),
  file = paste("limma_voom_log2CPM_TMM_scaled_counts.tsv"),
  row.names = F,
  sep = "\t",
  quote = F
)
```

The red line in the voom plot above represents the estimated mean–variance trend used to calculate precision weights for each gene and sample in limma. The plot typically shows a decreasing relationship between mean expression and variance. Flatter curves indicate greater biological variation, while steeper declines suggest more consistent expression across replicates. 

Moreover, the voom-plot provides a visual check on the level of filtering performed upstream. If filtering of lowly-expressed genes is insufficient, a drop in variance levels can be observed at the low end of the expression scale due to very small counts. If this is observed, additional filtering step should be performed proir to running voom.
</details>

## Exploratory plots

This section contains exploratory plots to visualize the normalized expression data and examine inter-sample clustering. Principal component analysis (PCA) and multidimensional scaling (MDS) were performed on the normalized expression values to reduce the dimensionality of the data and identify major sources of variation. This helps to detect patterns, clusters, or outliers in the dataset, which can provide insights into the relationships between samples.

### After Normalization {.tabset}

#### 3D PCA plots

PCA of the normalized expression data colored by the following different variables of interest: `r unique(sort(setdiff(names(groupinfo), "Sample")))`. To change the coloring of the PCA plot, please use the drop down menu below.

```{r 3d-expression-pca-after-normalization, out.width='75vh', out.height='50vh', fig.align='center'}
# Order genes by MAD, limma voom
# returns an Elist object where
# v$E corresponds to a numeric 
# matrix of normalized expression
# values, scaled log2CPM. Scaling
# is calculated by edgeR's TMM
# calcNormFactors function.
norm_data <- voom_object  # Need unfiltered object later with Glimma
pca_data <- voom_object
pca_data$E <- pca_data$E[order(apply(pca_data$E, 1, mad), decreasing = T), ]

# Remove zero variance rows prior to PC
pca_data$E <- pca_data$E[apply(pca_data$E, 1, var) != 0, ]

# Principal component analysis
# of normalized expression matrix,
# first three PCs for the 3D plotly
# scatter plot can be accessed via
# the following: pca$x[,1:3]
pca <- prcomp(
  t(as.matrix(pca_data$E)), scale. = T
)

# Merge both dataframes on rowname
metadata <- transform(
    merge(groupinfo,
          as.data.frame(pca$x[, 1:3]),
          by = 'row.names',
          all = TRUE
    ),
    row.names = Row.names,
    Row.names = NULL
)

# Calculating the amount of variance
# explained by the first three PCs
pc1 <- round(pca$sdev[1]^2 / sum(pca$sdev^2)*100, 2)
pc2 <- round(pca$sdev[2]^2 / sum(pca$sdev^2)*100, 2)
pc3 <- round(pca$sdev[3]^2 / sum(pca$sdev^2)*100, 2)

# Selects which columns should be 
# included dropdown to change the
# coloring of PCA plot, ignores
# "Sample" column
color_vars <- setdiff(names(groupinfo), "Sample")
for (v in color_vars) metadata[[v]] <- addNA(factor(metadata[[v]]))

# Generates color palettes for
# the different levels of each
# factor variable
make_palette <- function(n) {
  base <- brewer.pal(12, "Paired")
  colorRampPalette(base)(n)
}

# At a high-level, this creates one trace
# per level for each color variable (i.e
# Group, Batch, Sex, etc). Then, it creates
# dropdown menu to toggle visibility of the
# traces based on which variable is selected
# by the user.
fig <- plot_ly()
trace_var_index <- character(0)
# Build one trace per level 
# for each color variable
for (v in color_vars) {
  # Get the levels for the variable
  # and create its color palette
  lvls <- levels(metadata[[v]])
  pal  <- make_palette(length(lvls))
  for (i in seq_along(lvls)) {
    # Get the level and subset
    # the metadata
    lvl  <- lvls[i]
    dsub <- metadata[metadata[[v]] %in% lvl, , drop = FALSE]
    # Creating on hover text dynamically
    # to include additional metadata for
    # each sample, excluding default columns
    # (i.e PC1, PC2, PC3, Sample) and the
    # selected variable v to avoid duplicates
    base_other_cols <- setdiff(names(metadata), c("PC1","PC2","PC3","Sample","Group"))
    other_cols_v <- setdiff(base_other_cols, v)
    # Builds an HTML string for each
    # row in dsub with the extra metadata
    extras <- if (length(other_cols_v)) {
      apply(dsub[, other_cols_v, drop = FALSE], 1, function(r) {
        paste(paste0("<br><b>", names(r), ":</b> ", r), collapse = "")
      })
    } else rep("", nrow(dsub))
    # Only add the selected variable line 
    # when it's not Group (to avoid the duplicate)
    v_line <- if (v != "Group") paste0("<br><b>", v, ":</b> ", dsub[[v]]) else ""
    # Full hover text for this sample
    hover_text <- paste0(
      "<b>Sample:</b> ", dsub$Sample,
      "<br><b>Group:</b> ", dsub$Group,
      v_line,
      extras
    )
    # Add a trace for this level
    fig <- fig %>%
      add_markers(
        data = dsub,
        x = ~PC1, y = ~PC2, z = ~PC3,
        name = paste0(lvl),
        # only the first variable starts visible
        visible = if (v == color_vars[1]) TRUE else FALSE,
        showlegend = TRUE,
        marker = list(size = 8, color = pal[i]),
        hoverinfo = "text",
        text = hover_text
      )
    # Remember which variable this trace 
    # belongs to for the visibility masks
    trace_var_index <- c(trace_var_index, v)
  }
}

# Dropdown buttons toggle visibility masks
# and update the plot titles
buttons <- lapply(color_vars, function(v) {
  vis_mask <- trace_var_index == v
  list(
    method = "update",
    label  = v,
    args   = list(
      list(visible = as.list(vis_mask)),
      list(
        title  = paste("PCA colored by", v),
        legend = list(title = list(text = v)),
        scene  = list(
          xaxis = list(title = paste0("PC1 (", pc1, "%)")),
          yaxis = list(title = paste0("PC2 (", pc2, "%)")),
          zaxis = list(title = paste0("PC3 (", pc3, "%)"))
        )
      )
    )
  )
})

# Creates the final plotly object
# with the layout and dropdown menu
p <- fig %>%
  layout(
    title  = paste("PCA colored by", color_vars[1]),
    scene  = list(
      xaxis = list(title = paste0("PC1 (", pc1, "%)")),
      yaxis = list(title = paste0("PC2 (", pc2, "%)")),
      zaxis = list(title = paste0("PC3 (", pc3, "%)"))
    ),
    legend = list(title = list(text = color_vars[1])),
    updatemenus = list(list(
      type = "dropdown",
      x = 0, y = 1.15, xanchor = "left", yanchor = "top",
      buttons = buttons,
      bgcolor = "white",
      bordercolor = "lightgray"
    ))
  ) %>%
  config(toImageButtonOptions = list(format = "svg"))

# Disable onclick behavior
plotly::highlight(p, on = NULL)
```

The interactive 3D PCA plot above visualizes the clustering of samples based on the first three principal components (PCs) of the normalized gene expression data. Each point represents a sample, colored by the variable selected in the drop down. The axes indicate the percentage of variance explained by each PC, providing insights into the major sources of variation in the dataset.

#### 2D MDS plots

```{r 3d-expression-mds-after-normalization, fig.align='center'}
timestamp("Generating Glimma MDS plot using normalized data. Preview of data (10 rows):\n", head(as.data.frame(norm_data$E), 10))
Glimma::glimmaMDS(
  as.matrix(norm_data$E),
  groups = groupinfo,
  labels = groupinfo$Sample,
  width = 1100,
  top = nrow(norm_data$E),
)
```

The MDS plot above visualizes the similarity between samples based on their normalized expression profiles. Each point represents a sample, and the distances between points reflect the overall differences in expression patterns. Samples that cluster closely together have similar expression profiles, while those that are farther apart exhibit greater differences. This plot helps to identify potential outliers and assess the consistency of replicates within experimental groups.


`r if (run_corrected_pca) { 
  sprintf("### After Covariate Correction {.tabset}\n#### 3D PCA plots\nPCA of the normalized, covariate-corrected expression data colored by the same variables of interest. These counts have been corrected for any unwanted effects due to the following covariates: %s. To change the coloring of the PCA plot, please use the drop down menu below.", params$covariates)
}`

```{r 3d-expression-pca-after-batch-correction, eval=run_corrected_pca, out.width='75vh', out.height='50vh', fig.align='center'}
# Using limma's removeBatchEffect
# function to visulize the effect
# after correcting/adjusting the
# additive effect of the covariates.
# These counts should ONLY be used
# for data visulization purposes
# and then should not be used to 
# make any statistical inferences
# OR downstream for differential
# gene expression analysis.
cv <- trimws(unlist(strsplit(params$covariates, split = ",")))
covariates <- groupinfo[ , intersect(names(groupinfo), cv), drop = FALSE]
# Create model matrix for covariates,
# pass this to removeBatchEffect. This
# allows for adjustment of multiple
# covariates at once. It basically
# one hot encodes the covariates.
covariates <- model.matrix(~ . - 1, data = covariates)
timestamp("Using one hot encoding of covariates for batch correction:\n", as.data.frame(covariates))
norm_data <- removeBatchEffect(voom_object, group=as.factor(groupinfo$Group), covariates=covariates)
pca_data <- norm_data  # Need unfiltered object later with Glimma

# Order genes by MAD, limma voom
# returns an Elist object where
# v$E corresponds to a numeric 
# matrix of normalized expression
# values, scaled log2CPM. Scaling
# is calculated by edgeR's TMM
# calcNormFactors function.
pca_data <- pca_data[order(apply(pca_data, 1, mad), decreasing = T), ]

# Write the batch corrected counts
# to an output file for any later
# data visualization requests
write.table(
  data.frame("ensid_gene" = rownames(pca_data), pca_data),
  file = paste("limma_voom_removeBatchEffect_corrected_counts.tsv"),
  row.names = F,
  sep = "\t",
  quote = F
)

# Remove zero variance rows prior to PC
pca_data <- pca_data[apply(pca_data, 1, var) != 0, ]

# Principal component analysis
# of normalized expression matrix,
# first three PCs for the 3D plotly
# scatter plot can be accessed via
# the following: pca$x[,1:3]
pca <- prcomp(
  t(as.matrix(pca_data)), scale. = T
)

# Merge both dataframes on rowname
metadata <- transform(
    merge(groupinfo,
          as.data.frame(pca$x[, 1:3]),
          by = 'row.names',
          all = TRUE
    ),
    row.names = Row.names,
    Row.names = NULL
)

# Calculating the amount of variance
# explained by the first three PCs
pc1 <- round(pca$sdev[1]^2 / sum(pca$sdev^2)*100, 2)
pc2 <- round(pca$sdev[2]^2 / sum(pca$sdev^2)*100, 2)
pc3 <- round(pca$sdev[3]^2 / sum(pca$sdev^2)*100, 2)

# Selects which columns should be 
# included dropdown to change the
# coloring of PCA plot, ignores
# "Sample" column
color_vars <- setdiff(names(groupinfo), "Sample")
for (v in color_vars) metadata[[v]] <- addNA(factor(metadata[[v]]))

# Generates color palettes for
# the different levels of each
# factor variable
make_palette <- function(n) {
  base <- brewer.pal(12, "Paired")
  colorRampPalette(base)(n)
}

# At a high-level, this creates one trace
# per level for each color variable (i.e
# Group, Batch, Sex, etc). Then, it creates
# dropdown menu to toggle visibility of the
# traces based on which variable is selected
# by the user.
fig <- plot_ly()
trace_var_index <- character(0)
# Build one trace per level 
# for each color variable
for (v in color_vars) {
  # Get the levels for the variable
  # and create its color palette
  lvls <- levels(metadata[[v]])
  pal  <- make_palette(length(lvls))
  for (i in seq_along(lvls)) {
    # Get the level and subset
    # the metadata
    lvl  <- lvls[i]
    dsub <- metadata[metadata[[v]] %in% lvl, , drop = FALSE]
    # Creating on hover text dynamically
    # to include additional metadata for
    # each sample, excluding default columns
    # (i.e PC1, PC2, PC3, Sample) and the
    # selected variable v to avoid duplicates
    base_other_cols <- setdiff(names(metadata), c("PC1","PC2","PC3","Sample","Group"))
    other_cols_v <- setdiff(base_other_cols, v)
    # Builds an HTML string for each
    # row in dsub with the extra metadata
    extras <- if (length(other_cols_v)) {
      apply(dsub[, other_cols_v, drop = FALSE], 1, function(r) {
        paste(paste0("<br><b>", names(r), ":</b> ", r), collapse = "")
      })
    } else rep("", nrow(dsub))
    # Only add the selected variable line 
    # when it's not Group (to avoid the duplicate)
    v_line <- if (v != "Group") paste0("<br><b>", v, ":</b> ", dsub[[v]]) else ""
    # Full hover text for this sample
    hover_text <- paste0(
      "<b>Sample:</b> ", dsub$Sample,
      "<br><b>Group:</b> ", dsub$Group,
      v_line,
      extras
    )
    # Add a trace for this level
    fig <- fig %>%
      add_markers(
        data = dsub,
        x = ~PC1, y = ~PC2, z = ~PC3,
        name = paste0(lvl),
        # only the first variable starts visible
        visible = if (v == color_vars[1]) TRUE else FALSE,
        showlegend = TRUE,
        marker = list(size = 8, color = pal[i]),
        hoverinfo = "text",
        text = hover_text
      )
    # Remember which variable this trace 
    # belongs to for the visibility masks
    trace_var_index <- c(trace_var_index, v)
  }
}

# Dropdown buttons toggle visibility masks
# and update the plot titles
buttons <- lapply(color_vars, function(v) {
  vis_mask <- trace_var_index == v
  list(
    method = "update",
    label  = v,
    args   = list(
      list(visible = as.list(vis_mask)),
      list(
        title  = paste("PCA colored by", v),
        legend = list(title = list(text = v)),
        scene  = list(
          xaxis = list(title = paste0("PC1 (", pc1, "%)")),
          yaxis = list(title = paste0("PC2 (", pc2, "%)")),
          zaxis = list(title = paste0("PC3 (", pc3, "%)"))
        )
      )
    )
  )
})

# Creates the final plotly object
# with the layout and dropdown menu
p <- fig %>%
  layout(
    title  = paste("PCA colored by", color_vars[1]),
    scene  = list(
      xaxis = list(title = paste0("PC1 (", pc1, "%)")),
      yaxis = list(title = paste0("PC2 (", pc2, "%)")),
      zaxis = list(title = paste0("PC3 (", pc3, "%)"))
    ),
    legend = list(title = list(text = color_vars[1])),
    updatemenus = list(list(
      type = "dropdown",
      x = 0, y = 1.15, xanchor = "left", yanchor = "top",
      buttons = buttons,
      bgcolor = "white",
      bordercolor = "lightgray"
    ))
  ) %>%
  config(toImageButtonOptions = list(format = "svg"))

# Disable onclick behavior
plotly::highlight(p, on = NULL)
```

`r if (run_corrected_pca) {
  sprintf("#### 2D MDS plots\n")
}`

```{r 3d-expression-mds-after-batch-correction, fig.align='center'}
timestamp("Generating Glimma MDS plot using batch-corrected normalized data. Preview of data (10 rows):\n", head(as.data.frame(norm_data), 10))
Glimma::glimmaMDS(
  as.matrix(norm_data),
  groups = groupinfo,
  labels = groupinfo$Sample,
  width = 1100,
  top = nrow(norm_data),
)
```

`r if (run_corrected_pca) {
  sprintf("The MDS plot above visualizes the similarity between samples based on their covariate-corrected normalized expression profiles. Each point represents a sample, and the distances between points reflect the overall differences in expression patterns. Samples that cluster closely together have similar expression profiles, while those that are farther apart exhibit greater differences. This plot helps to identify how well adjusting for the specified covariates has mitigated unwanted variation and improved the clustering of samples according to their biological groups of interest.\n")
}`

## Differential gene expression analysis

This experiment aims to identify genes that are differentially expressed between experimental groups of interest.

Group comparisons are defined as contrasts, and differential expression is assessed using the [R package limma](https://bioconductor.org/packages/release/bioc/html/limma.html). The functions `limma::lmFit()`, `limma::contrasts.fit()`, and `limma::eBayes()` fit linear models to each gene and apply empirical Bayes moderation to improve the variance estimates by borrowing information across all genes. This step is important because it stabilizes the variance estimates (especially when sample sizes are small) leading to more reliable detection of truly differentially expressed genes. P-values are then adjusted for multiple testing using the false discovery rate (FDR) method.

### Comparisons of interest

Here is a table containing the differential expression comparisons to perform. Each row represents a comparison between two experimental groups. The control group represents the baseline group of the comparison.

```{r comparisons-table, results='asis'}
# Fold-change and FDR thresholds
# for filtering significant genes
fc.threshold <- 1.5
fdr.threshold <- 0.1

contrast_df <- contrastinfo
colnames(contrast_df) <- c("Case", "Control")
DT::datatable(
    contrast_df,
    extensions = c(
      "Buttons",       # add download buttons
      "Scroller",      # for scrolling instead of pagination
      "FixedColumns",  # freeze columns in datatable
      "SearchBuilder"  # create complex search queries
    ),
    rownames = FALSE,  # keep rownames
    style = "auto",
    width = "100%",
    options = list(
      dom = "QBlrtip", # specify content (search box, etc)
      deferRender = TRUE,
      scrollX = TRUE,
      scrollY = min(400, 40 * nrow(contrast_df)),
      scroller = TRUE,
      fixedColumns = list(leftColumns = 1), # freeze left columns
      buttons = list(
        list(
          extend = "copyHtml5",
          title = NULL
        ),
        list(
            extend = "csv",               # download as .csv
            filename = "contrasts_file"   # output file
        ),
        list(
            extend = "excel",             # download as .xlsx
            filename = "contrasts_file"   # output file
        )
      )
    ),
)
```


```{r template_chunks, echo=FALSE}
deg_template <- '#### **{{grp1}}<br><i><u>vs.</u></i> {{grp2}}** {.tabset}

##### Results 

**{{grp1}}** <u>_**vs.**_</u> **{{grp2}}**

This section contains the results of the differential gene expression analysis between the `{{grp1}}` and `{{grp2}}` groups using the [R package limma](https://bioconductor.org/packages/release/bioc/html/limma.html). 

<details>
  <summary>*Interpreting the fold-change*</summary>
    If a gene has a positive fold-change (FC) value, it indicates that the gene is <span style="color:darkgreen">**up-regulated** (i.e its expression is higher)</span> in the `{{grp1}}` group compared to the `{{grp2}}` group. Conversely, a negative FC value indicates that the gene is <span style="color:darkred">**down-regulated** (i.e its expression is lower)</span> in the `{{grp1}}` group compared to the `{{grp2}}` group.
</details> 

\`\`\`{r compare-{{grp1}}_vs_{{grp2}}, out.width="100%"} 
# Creating a contrast matrix
timestamp("Running differential expression comparison: {{grp1}} vs. {{grp2}}")
contrast <- limma::makeContrasts(
  {{grp1}} - {{grp2}},
  levels = colnames(design)
)

# Replace any instance of (A + B + C)/n with avg(A + B + C),
# we cannot create files with a / in the name
ofh_grp1 <- gsub("\\\\(([^()]+)\\\\)\\\\s*/\\\\s*\\\\d+", "avg(\\\\1)", "{{grp1}}")
ofh_grp2 <- gsub("\\\\(([^()]+)\\\\)\\\\s*/\\\\s*\\\\d+", "avg(\\\\1)", "{{grp2}}")
# Create sub-directory for each comparisons results
cmp_name <- paste(ofh_grp1, ofh_grp2, sep="_vs_")
cmp_subdir <- file.path(wd, cmp_name)
if (!dir.exists(cmp_subdir)) {
  dir.create(cmp_subdir, recursive = TRUE)
}

# Fits linear models using a
# contrast to each gene
voom.fit <- limma::contrasts.fit(fit, contrasts = contrast)
ebayes.fit <- limma::eBayes(voom.fit)
# Get the results of the
# differential expression
# analysis for a genes
results.table <- limma::topTable(
  ebayes.fit,
  adjust.method = "fdr",
  sort.by = "B",
  n = Inf
)

# Calculating a generic
# fold-change from the
# lof2FC, new scale goes 
# from: -inf...-1 TO 1...+inf
results.table$FC <- ifelse(
  results.table$logFC<0, 
  -1/(2^results.table$logFC),
  2^results.table$logFC
)

# Calculating a pre-ranked 
# score for GSEA
results.table$prerank_score = -1 * (
  log10(results.table$P.Value) * sign(results.table$logFC)
)

# Reorder the topTable results
results.table <- dplyr::select(
  results.table,
  "FC",
  "logFC",
  "AveExpr",
  "t",
  "B",
  "prerank_score",
  "P.Value",
  "adj.P.Val"
)

# Sort the results by P.Value
results.table <- results.table[
  order(results.table$P.Value, decreasing = FALSE), 
]

# Filter table to find significant
# differentially expressed genes
sig.table <- results.table[
  which(
    abs(results.table$FC) >= fc.threshold & results.table$adj.P.Val <= fdr.threshold
  ),
]

# Get the number of up-regulated
# significant genes 
up.regulated <- nrow(
  sig.table[
    which(
      sig.table$FC >= fc.threshold
    ),
  ]
)
# Get the number of down-regulated
# significant genes 
down.regulated <- nrow(
  sig.table[
    which(
      sig.table$FC <= -fc.threshold
    ),
  ]
)

# Note the use of the results="asis" chunk
# option above. This is required to ensure 
# that the raw table output isnt processed
# further by knitr.
# Create interactive datatable with metadata
DT::datatable(
    data.frame("ensid_gene" = rownames(sig.table), sig.table),
    extensions = c(
      "Buttons",       # add download buttons
      "Scroller",      # for scrolling instead of pagination
      "FixedColumns",  # freeze columns in datatable
      "SearchBuilder"  # create complex search queries
    ),
    rownames = FALSE,  # keep rownames?
    style = "auto",
    width = "100%",
    options = list(
      dom = "QBflrtip", # specify content (search box, etc)
      deferRender = TRUE,
      scrollX = TRUE,
      scrollY = 600,
      scroller = TRUE,
      fixedColumns = list(leftColumns = 1), # freeze left columns
      buttons = list(
        list(
          extend = "copyHtml5",
          text = "Copy genes symbols",
          # Hides header to adds by default
          title = NULL,
          # Index of the rownames column
          exportOptions = list(
            columns = 0
          )
        ),
        list(
            # download as .csv
            extend = "csv",
            # output filename
            filename = paste(
              "limma_voom_deg_",
              paste(ofh_grp1, ofh_grp2, sep = "_vs_"),
              sep = ""
          )
        ),
        list(
            # download as .xlsx
            extend = "excel",
            # Output filename
            filename = paste(
              "limma_voom_deg_",
              paste(ofh_grp1, ofh_grp2, sep = "_vs_"),
              sep = ""
          )
        )
      )
    ),
)

# Write results of differential
# expression analysis to a file
write.table(
  data.frame("ensid_gene" = rownames(results.table), results.table),
  file = file.path(
    cmp_subdir,
    paste(
      "limma_voom_deg_",
      paste(ofh_grp1, paste(ofh_grp2, ".tsv", sep=""), sep = "_vs_"),
      sep = ""
    )
  ),
  row.names = F,
  sep = "\\t",
  quote = F
)

# Write coefficents of limmas linear model
# to an output file, the FC is calculated
# from these value which conceptually 
# represents the mean expression of each 
# level in a factor.
write.table(
  data.frame("ensid_gene" = rownames(coef(fit)), coef(fit)),
  file = file.path(
    cmp_subdir,
    paste(
      "limma_voom_linear_model_coefficients_",
      paste(ofh_grp1, paste(ofh_grp2, ".tsv", sep=""), sep = "_vs_"),
      sep = ""
    )
  ),
  row.names = F,
  sep = "\\t",
  quote = F
)
\`\`\`

<details>
  <summary>*About filtering, sorting, exporting the table*</summary>
    The table below can be filtered and sorted interactively to explore the results. To filter the table, please use the *Add Condition* button. It can be used to create complex queries to filter the table. To sort the table, click on the column headers. The *Copy gene symbols* button can be used to copy the gene symbols of the currently displayed genes. The *CSV* and *Excel* buttons can be used to download the full table in the respective formats.
</details>
<br>

> **Summary of the results**
>  
> The table has been filtered to highlight significant differentially expressed genes that meet the following thresholds: **FDR-adjusted p-value ≤ \`r fdr.threshold\`** and **|fold-change| ≥ \`r fc.threshold\`**. In total, **\`r up.regulated + down.regulated\` gene(s)** meet these filtering criteria, of which <span style="color:darkgreen"> **\`r up.regulated\` gene(s)**</span> are up-regulated and <span style="color:darkred"> **\`r down.regulated\` gene(s)**</span> are down-regulated genes. 
> 
> The **complete, unfiltered** differential gene expression results are available in the file:  
> \`r file.path(cmp_name, paste("limma_voom_deg_", paste(ofh_grp1, paste(ofh_grp2, ".tsv", sep=""), sep = "_vs_"), sep = ""))\`.
 
##### Volcano Plot

**{{grp1}}** <u>_**vs.**_</u> **{{grp2}}**

This section contains a VolcanoPlot created with the [R package, EnhancedVolcano ](https://bioconductor.org/packages/devel/bioc/vignettes/EnhancedVolcano/inst/doc/EnhancedVolcano.html). The plot visualizes the top 10 up- and down-regulated genes based on the following adjusted p-value and fold-change thresholds: **FDR adjusted p-value ≤ \`r fdr.threshold\`** AND **abs(FC) ≥ \`r fc.threshold\`**. 

\`\`\`{r {{grp1}}-{{grp2}}-volcano, out.width="100%"}
# Get top 10 up- and down-regulated
# genes for the volcano plot 
top.up.regulated.genes <- gsub(
  ".*\\\\|",
  "",
  head(
    rownames(
      sig.table[
        which(
          sig.table$FC >= fc.threshold
        ),
      ]
    ),
    n = 10
  )
)

top.down.regulated.genes <- gsub(
  ".*\\\\|",
  "",
  head(
    rownames(
      sig.table[
        which(
          sig.table$FC <= -fc.threshold
        ),
      ]
    ),
    n = 10
  )
)

# Create a volcano plot to visualize
# the top differential expressed genes
EnhancedVolcano::EnhancedVolcano(
  results.table,
  title = "",
  subtitle = bquote(italic("{{grp1}} vs. {{grp2}}")),
  caption = paste0("total = ", nrow(results.table), " genes"),
  lab = gsub(".*\\\\|", "", rownames(results.table)),
  selectLab = c(top.up.regulated.genes, top.down.regulated.genes),
  x = "logFC",
  y = "adj.P.Val",
  ylim = c(0, max(-log10(results.table$adj.P.Val), na.rm = TRUE) + 0.1),
  ylab = bquote(~-Log[10] ~ italic("adj. P-value")),
  legendLabels = c(
    "Not significant",
    expression(Log[2] ~ FC),
    "adj P",
    expression(adj ~ P ~ and ~ log[2] ~ FC)
  ),
  pCutoff = fdr.threshold,
  FCcutoff = log2(fc.threshold),
  labSize = 2.8,
  drawConnectors = T,
  widthConnectors = 0.55,
  min.segment.length = 2.0,
  colAlpha = 1,
  legendPosition = "right",
  legendLabSize = 12,
  legendIconSize = 4.0
)

# Save the volcano plot as a jpeg
ggplot2::ggsave(
  filename = file.path(
    cmp_subdir,
    paste(
      "limma_voom_volcano_plot_",
      paste(ofh_grp1, ofh_grp2, sep = "_vs_"),
      ".jpeg",
      sep = ""
    )
  ),
  width = 12,
  height = 10,
  dpi = 300
)

# Save the as a pdf
ggplot2::ggsave(
  filename = file.path(
    cmp_subdir,
    paste(
      "limma_voom_volcano_plot_",
      paste(ofh_grp1, ofh_grp2, sep = "_vs_"),
      ".pdf",
      sep = ""
    )
  ),
  width = 12,
  height = 10
)

# Create an interactive Volcano plot
# with the R package Glimma, the object
# passed to the counts parameter must
# contains all the tested genes. If it
# does not, the it messes up the mappings
# between the DGE results and the counts
# and the plot will be incorrect, meaning
# it could display information for a
# different gene.
interactive_volcano_plot <- Glimma::glimmaVolcano(
  ebayes.fit,
  counts = norm_data,
  groups = groupinfo$Group,
  coef = 1,
  transform.counts = "none",
  status = limma::decideTests(
    ebayes.fit,
    adjust.method = "BH",
    p.value = fdr.threshold,
    lfc = log2(fc.threshold)
  )
)
# Save the volcano plot widget to
# a seperate HTML file
htmlwidgets::saveWidget(
  interactive_volcano_plot,
  file = paste(
      "glimma_interactive_volcano_plot_",
      paste(ofh_grp1, ofh_grp2, sep = "_vs_"),
      ".html",
      sep = ""
    ),
  selfcontained = TRUE
)
# Cannot create file in cmp_subdir directly
# without assest removal handled automatically,
# create in wd and then move the HTML file
# into its correct folder, this is a known
# issue that occurs when the file is created
# in a directory outside the wd.
status <- file.rename(
  from = paste(
    "glimma_interactive_volcano_plot_",
    paste(ofh_grp1, ofh_grp2, sep = "_vs_"),
    ".html",
    sep = ""
  ),
  to = file.path(
    cmp_subdir,
    paste(
      "glimma_interactive_volcano_plot_",
      paste(ofh_grp1, ofh_grp2, sep = "_vs_"),
      ".html",
      sep = ""
    )
  )
)
\`\`\`
\n\n'
```

### Differential expression results {.tabset}

The following sections present the differential gene expression results for each comparison. Each comparison includes two tabs: one with filtered results (i.e. Results) and another tab showing a volcano plot highlighting the top differentially expressed genes (i.e. Volcano Plot). 

Only significant genes are shown, defined by an **FDR-adjusted p-value ≤ `r fdr.threshold`** and **abs(fold change) ≥ `r fc.threshold`**. The complete, unfiltered results for each comparison are also available as a TSV file.

```{r run-deg-comparisons, results='asis'}
# Ensure character columns, by coverting
# any factors to characters
contrastinfo[] <- lapply(contrastinfo, as.character)
# Creates a list of comparisons
# with the following structure:
# list(
#   c("KO_A",  "WT_A"),
#   c("KO_B",  "WT_B"),
#   c("(KO_A-WT_A)",  "(KO_B-WT_B)"),
#   c("(KO_A+KO_B)/2",  "(WT_A+WT_B)/2"),
#   ...
# )
comparisons <- lapply(seq_len(nrow(contrastinfo)), function(i) {
  unname(as.character(contrastinfo[i, ]))
})

# Loop over each comparison and
# perform differential expression
# analysis using limma
for (cmp in comparisons) {
    grp1 <- cmp[1]
    grp2 <- cmp[2]
    # knitr expands the template and
    # renders the chunk into the Rmd
    # report, the deg_template peforms
    # DGE analysis and creates a volcano
    # plot for each comparison
    deg_chunk <- knitr::knit_expand(text = deg_template)
    rendered_chunk <- knitr::knit(text = deg_chunk, quiet = TRUE)
    # NOTE: result="asis" is needed to properly 
    # render the rendered chunk object
    cat(rendered_chunk)
}
```

## Session Information

<details>
  <summary>View Details</summary>
`r suppressMessages(library(pander)); pander(sessionInfo(), compact = F)`
</details>


<!-- This will remove any unwanted white space -->
<!-- at the bottom of the rendered HTML file. -->
<div class="tocify-extend-page" data-unique="tocify-extend-page" style="height: 0;"></div>
<br>
